================================================================================
    mlir-systolic 动态枚举需求分析 - 最终总结
================================================================================

日期：2026-01-14
问题：是否需要恢复动态枚举功能？固定模式为什么对多循环kernel失效？

================================================================================
                              结论
================================================================================

✅ YES - 必须需要动态枚举

理由：
  1. 固定模式仅支持 3 个循环（ST0-ST5），对 4+ 循环完全失效
  2. MTTKRP、TTMC (4 循环) 需要 10+ 种配置
  3. CNN (5 循环) 需要 25+ 种配置
  4. 项目规划明确要求支持这些 kernel
  5. 与 AutoSA 不对标，AutoSA 对 4+ 循环也用动态枚举

================================================================================
                           核心问题分析
================================================================================

1. 固定模式的硬编码
   ├─ 循环索引固定为 0, 1, 2
   ├─ 只支持 ST0-ST5 这 6 种模式
   └─ 对 4+ 循环无法表达新的配置组合

   位置：lib/Transforms/SystolicTransform.cpp L300-370
   函数：selectSpaceLoops()

2. AutoSA 的处理方式
   ├─ 3 循环：使用 ST0-ST5（与我们相同）
   ├─ 4 循环：动态枚举 10+ 种配置
   ├─ 5 循环：动态枚举 25+ 种配置
   └─ 关键：通过组合不同循环维度来生成配置

3. 为什么固定模式失效？
   
   案例 1：MTTKRP (4 循环)
   ─────────────────────
   for i, j, k, l:
     D[i,j] += A[i,k,l] * B[k,l,j]
   
   可能的空间维度组合：
     1D：[0], [1], [2], [3]              (4 种)
     2D：[0,1], [0,2], [0,3], 
         [1,2], [1,3], [2,3]             (6 种)
     总计：10 种
   
   固定模式只能表达 6 种（ST0-ST5），无法表达：
     ❌ [0,3]：i 和 l 作为空间维度
     ❌ [1,3]：j 和 l 作为空间维度
     等等
   
   案例 2：CNN (5 循环)
   ─────────────────────
   for h, w, c_in, c_out, n:
   
   可能的组合：
     1D：5 种
     2D：C(5,2) = 10 种
     3D：C(5,3) = 10 种
     总计：25 种
   
   固定模式完全无法应对。

================================================================================
                           代码现状
================================================================================

当前代码中的两套体系：

1. 固定模式（正在使用）
   ├─ selectSpaceLoops(): [lib/Transforms/SystolicTransform.cpp L300]
   ├─ 支持 ST0-ST5
   ├─ 限制：numLoops < 3 时返回 failure()
   └─ 问题：4+ 循环时无法工作

2. 参数化框架（已实现但未充分使用）
   ├─ ParametricSpaceTime 类：[include/systolic/Analysis/ParametricSpaceTime.h]
   ├─ selectSpaceLoopsParametric()：[lib/Transforms/SystolicTransform.cpp L220]
   ├─ 优点：支持任意循环数和组合
   └─ 状态：代码完整，缺少枚举函数

3. 动态枚举（已删除）
   ├─ enumerateSpaceTimeConfigs(): 已被删除
   ├─ 删除量：161 行代码
   ├─ 删除范围：
   │  ├─ 函数实现本身
   │  ├─ 相关文档（docs/features/spacetime/SPACETIME_DYNAMIC_ENUMERATION.md）
   │  └─ 相关测试（test/spacetime-enumeration.mlir 等）
   └─ 时间：约 1-2 周前

================================================================================
                        项目规划中的承诺
================================================================================

1. docs/reference/autosa/AUTOSA_ANALYSIS.md
   └─ 明确说明 AutoSA 对 4+ 循环使用动态枚举

2. docs/features/spacetime/SPACETIME_IMPLEMENTATION_PLAN.md
   └─ 详细规划了动态枚举的实现步骤和测试计划
   └─ 明确列出了支持 3、4、5 循环的要求

3. docs/status/IMPLEMENTATION_STATUS.md
   └─ 说"枚举功能已实现，待验证"
   └─ 列出了 MTTKRP、TTMC、CNN 的测试计划

4. scripts/generate_autosa_reference.py
   └─ 为 MTTKRP、TTMC、CNN 预留了配置空间
   └─ 说明这些 kernel 是项目的目标

================================================================================
                        为什么可以删除？
================================================================================

1. 目前只测试了 MM (3 循环)
   └─ 固定模式足以支持

2. MTTKRP、TTMC、CNN 还没有真正集成测试
   └─ 动态枚举的必要性在文档上体现，但在实际测试中不明显

3. 固定模式的代码更简单、更容易理解
   └─ 便于快速验证 3 循环的功能

4. 可能觉得 ParametricSpaceTime 框架已经足够支持
   └─ 虽然框架完整，但缺少枚举的"入口函数"

================================================================================
                          为什么要恢复？
================================================================================

1. 项目承诺和规划明确
   └─ 无法推卸：文档中明确列出了支持 4+ 循环的要求

2. AutoSA 对标
   └─ mlir-systolic 的目标就是重新实现 AutoSA 的功能
   └─ AutoSA 对 4+ 循环用动态枚举，我们也应该

3. 实现已经完成
   └─ ParametricSpaceTime 框架完整
   └─ 只需恢复 161 行的枚举代码

4. 真实世界需求
   └─ CNN、MTTKRP 等多循环 kernel 很常见
   └─ 固定模式无法满足

5. 代码体系的完整性
   └─ 现在处于"一半完成"状态
   └─ 参数化框架是为动态枚举设计的
   └─ 删除枚举后框架就没有真正用到

================================================================================
                        技术实现概要
================================================================================

恢复步骤：

1. 恢复 enumerateSpaceTimeConfigs() 函数（~160 行）
   ├─ 枚举 1D 配置：for i in [0..numLoops-1]
   ├─ 枚举 2D 配置：for i,j in pairs
   └─ 枚举 3D 配置（可选）：for i,j,k in triples

2. 集成到 SystolicTransformPass::runOnOperation()
   ├─ 调用 enumerateSpaceTimeConfigs() 得到所有可能配置
   ├─ 默认选择 ST3 equivalent（最常用的 2D 输出驻留）
   └─ 支持用户通过 spaceTimeMode 参数选择

3. 添加 4+ 循环的测试用例
   ├─ test/4-loop-mttkrp.mlir
   ├─ test/5-loop-cnn.mlir
   └─ 验证至少 2-3 个不同的 spacetime 配置

4. 更新文档
   ├─ 恢复 SPACETIME_DYNAMIC_ENUMERATION.md
   ├─ 更新 IMPLEMENTATION_STATUS.md
   └─ 明确说明支持的 kernel 类型和循环数

工作量估计：
  ├─ 恢复/重实现代码：1-2 小时
  ├─ 测试和验证：2-3 小时
  ├─ 文档更新：1 小时
  └─ 总计：4-6 小时

================================================================================
                          推荐方案
================================================================================

选项 A：恢复动态枚举（推荐 ✅）
─────────────────────────────
优点：
  ✅ 符合项目规划
  ✅ 实现完整
  ✅ 与 AutoSA 对标
  ✅ 支持多样化 kernel
  ✅ 扩展性好

缺点：
  ⚠️ 增加一些代码复杂度
  ⚠️ 枚举有更多的配置需要验证

选项 B：保持固定模式（不推荐 ❌）
──────────────────────────────
优点：
  ✅ 代码简单
  ✅ 当前可用

缺点：
  ❌ 无法支持 MTTKRP、TTMC、CNN
  ❌ 背离项目规划
  ❌ 误导性强：文档说支持，代码实际不支持
  ❌ 后续扩展时需要重写

================================================================================
                          最终建议
================================================================================

立即行动：恢复动态枚举功能

理由充分：
  1. 项目规划明确 ✓
  2. 代码框架完整 ✓
  3. 工作量适中 ✓
  4. 与 AutoSA 对标 ✓
  5. 支持真实需求 ✓

下一步：
  1. 恢复 enumerateSpaceTimeConfigs() 代码
  2. 添加 4+ 循环测试
  3. 验证生成结果与 AutoSA 对齐
  4. 更新文档

================================================================================
