# mlir-systolic æ¶æ„æ¦‚è¿°

æœ¬æ–‡æ¡£æä¾› mlir-systolic é¡¹ç›®çš„é«˜å±‚æ¶æ„è§†å›¾ï¼Œå¸®åŠ©ç†è§£ç³»ç»Ÿçš„æ•´ä½“è®¾è®¡ã€ç»„ä»¶äº¤äº’å’Œæ•°æ®æµã€‚

## ç›®å½•

1. [ç³»ç»Ÿæ¦‚è¿°](#ç³»ç»Ÿæ¦‚è¿°)
2. [è®¾è®¡ç›®æ ‡](#è®¾è®¡ç›®æ ‡)
3. [æ ¸å¿ƒç»„ä»¶](#æ ¸å¿ƒç»„ä»¶)
4. [ç¼–è¯‘æµç¨‹](#ç¼–è¯‘æµç¨‹)
5. [æ•°æ®æµå›¾](#æ•°æ®æµå›¾)
6. [å…³é”®è®¾è®¡å†³ç­–](#å…³é”®è®¾è®¡å†³ç­–)
7. [æ‰©å±•æ€§è€ƒè™‘](#æ‰©å±•æ€§è€ƒè™‘)
8. [ä¸ AutoSA çš„å¯¹æ¯”](#ä¸-autosa-çš„å¯¹æ¯”)

---

## ç³»ç»Ÿæ¦‚è¿°

**mlir-systolic** æ˜¯ä¸€ä¸ªåŸºäº MLIR çš„è„‰åŠ¨é˜µåˆ—ä»£ç ç”Ÿæˆå™¨ï¼Œç”¨äºå°†é«˜å±‚ç®—æ³•ï¼ˆå¦‚çŸ©é˜µä¹˜æ³•ã€CNNã€å¼ é‡æ“ä½œï¼‰è‡ªåŠ¨è½¬æ¢ä¸ºé’ˆå¯¹ FPGA çš„é«˜æ•ˆ HLS C++ ä»£ç ã€‚

### æ ¸å¿ƒåŠŸèƒ½
- **å¤šæ€å¾ªç¯åˆ†æ**: åŸºäº Polymer/ISL çš„ Affine åˆ†æ
- **è„‰åŠ¨é…ç½®ç”Ÿæˆ**: æ”¯æŒ 6 ç§ spacetime é…ç½® (ST0-ST5)
- **æ•°æ®æµä¼˜åŒ–**: ç©ºé—´å¾ªç¯å±•å¼€ã€æ•°æ®æµæ’å…¥ã€æ•°ç»„åˆ†åŒº
- **HLS ä»£ç ç”Ÿæˆ**: ç”Ÿæˆå¸¦ä¼˜åŒ–æŒ‡ä»¤çš„ HLS C++ ä»£ç 

### æŠ€æœ¯æ ˆ
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         ç”¨æˆ·ç®—æ³• (C/MLIR)            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    MLIR Affine Dialect (IR)         â”‚  â† å¤šæ€å¾ªç¯è¡¨ç¤º
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Polymer/ISL (ä¾èµ–åˆ†æ)            â”‚  â† å¤šé¢ä½“åˆ†æ
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  mlir-systolic Transforms           â”‚  â† æœ¬é¡¹ç›®æ ¸å¿ƒ
â”‚  â€¢ SystolicTransform                â”‚
â”‚  â€¢ DataflowGeneration               â”‚
â”‚  â€¢ DataflowToHLS                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      HLS C++ Code (.cpp)            â”‚  â† Xilinx Vitis HLS
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## è®¾è®¡ç›®æ ‡

### ä¸»è¦ç›®æ ‡
1. **è‡ªåŠ¨åŒ–**: ä»ç®—æ³•åˆ°ç¡¬ä»¶ä»£ç çš„å…¨è‡ªåŠ¨ç”Ÿæˆ
2. **å¯é…ç½®æ€§**: æ”¯æŒå¤šç§ spacetime é…ç½®å’Œä¼˜åŒ–ç­–ç•¥
3. **é€šç”¨æ€§**: æ”¯æŒå¤šç§è®¡ç®—æ¨¡å¼ï¼ˆMMã€CNNã€å¼ é‡æ“ä½œï¼‰
4. **å¯æ‰©å±•æ€§**: æ˜“äºæ·»åŠ æ–°çš„ä¼˜åŒ– pass å’Œä»£ç ç”Ÿæˆç­–ç•¥

### å½“å‰é™åˆ¶ (å¾…æ”¹è¿›)
- ğŸ”´ **ST3-Only**: å½“å‰ä»…æ”¯æŒ spacetime=3 é…ç½®
- ğŸ”´ **MM-Specific**: ä»…é’ˆå¯¹ 3-loop çŸ©é˜µä¹˜æ³•ä¼˜åŒ–
- ğŸŸ¡ **é…ç½®æµæ··ä¹±**: å¤šæ¬¡åºåˆ—åŒ–é…ç½®å‚æ•°
- ğŸŸ¡ **Write-Time Reordering**: åˆ†æç»“æœæœªå®Œå…¨åº”ç”¨åˆ°ä»£ç ç”Ÿæˆ

---

## æ ¸å¿ƒç»„ä»¶

### 1. Transform å±‚ (`lib/Transforms/`)

è´Ÿè´£ Affine IR çš„é«˜å±‚è½¬æ¢å’Œä¼˜åŒ–ã€‚

#### SystolicTransform.cpp
- **èŒè´£**: 
  - æå–ç©ºé—´å¾ªç¯ (space loops)
  - æå–æ—¶é—´å¾ªç¯ (time loops)
  - æ·»åŠ  systolic å±æ€§åˆ° IR ä¸­
- **å…³é”®å‡½æ•°**:
  - `extractSpaceLoops()`: æ ¹æ® spacetime é…ç½®é€‰æ‹©ç©ºé—´å¾ªç¯
  - `extractTimeLoops()`: é€‰æ‹©æ—¶é—´ç»´åº¦
  - `annotateSystolicConfig()`: æ·»åŠ å±æ€§æ ‡è®°
- **å½“å‰é—®é¢˜**: 
  - ğŸ”´ ç¡¬ç¼–ç  `spacetime=3`ï¼ˆçº¦ 185-220 è¡Œï¼‰
  - ğŸ”´ å‡è®¾ 3-loop ç»“æ„

#### ArrayPartitioning.cpp
- **èŒè´£**: åˆ†æå’Œæ ‡è®°æ•°ç»„åˆ†åŒºç­–ç•¥
- **ç®—æ³•**: æ ¹æ®è®¿é—®æ¨¡å¼å†³å®š `complete`/`cyclic`/`block` åˆ†åŒº
- **è¾“å‡º**: ä¸ºæ¯ä¸ªæ•°ç»„æ·»åŠ åˆ†åŒºå±æ€§

### 2. Translation å±‚ (`lib/Translation/`)

è´Ÿè´£ä» MLIR è½¬æ¢åˆ°ç›®æ ‡ä»£ç ï¼ˆHLS C++ï¼‰ã€‚

#### SystolicDataflowGeneration.cpp
- **èŒè´£**:
  - ç”Ÿæˆæ•°æ®æµ IR (ä¸­é—´è¡¨ç¤º)
  - æ’å…¥ PE (Processing Element) å‡½æ•°
  - å¤„ç†æ•°ç»„åˆ†åŒºå’Œ FIFO æ’å…¥
- **å…³é”®æ•°æ®ç»“æ„**:
  - `DataflowNode`: è¡¨ç¤ºæ•°æ®æµèŠ‚ç‚¹ï¼ˆPEã€loadã€storeï¼‰
  - `FIFOConnection`: FIFO è¿æ¥ä¿¡æ¯
- **å½“å‰é—®é¢˜**:
  - ğŸ”´ ç¡¬ç¼–ç  3D æ•°ç»„å‡è®¾ï¼ˆçº¦ 210-240 è¡Œï¼‰
  - ğŸ”´ å›ºå®šçš„ FIFO æ·±åº¦è®¡ç®—

#### SystolicDataflowToHLS.cpp
- **èŒè´£**:
  - å°†æ•°æ®æµ IR è½¬æ¢ä¸º HLS C++ ä»£ç 
  - ç”Ÿæˆ PE å‡½æ•°ä½“ã€dataflow æŒ‡ä»¤ã€æ•°ç»„å£°æ˜
- **å…³é”®å‡½æ•°**:
  - `generatePEFunction()`: ç”Ÿæˆ PE å‡½æ•°
  - `generateDataflowPragmas()`: ç”Ÿæˆ HLS æŒ‡ä»¤
  - `migrateLoopBody()`: è¿ç§»å¾ªç¯ä½“åˆ° PEï¼ˆâš ï¸ æœªå®ç°ï¼‰
- **å½“å‰é—®é¢˜**:
  - ğŸ”´ Loop body migration æ˜¯ TODO
  - ğŸŸ¡ Write-time reordering æœªåº”ç”¨

### 3. Analysis å±‚ (`lib/Analysis/`)

æä¾›æ”¯æŒæ€§åˆ†æåŠŸèƒ½ã€‚

#### WriteTimeReordering.cpp
- **èŒè´£**: åˆ†ææ•°ç»„å†™æ—¶é—´ï¼Œä¼˜åŒ–å†™é¡ºåº
- **ç®—æ³•**: åŸºäº ISL ä¾èµ–åˆ†æ
- **å½“å‰çŠ¶æ€**: âœ… åˆ†æå®Œæˆï¼ŒğŸ”´ ç»“æœæœªåº”ç”¨åˆ°ä»£ç ç”Ÿæˆ

### 4. Dialect å±‚ (`lib/Dialect/Systolic/`)

å®šä¹‰ systolic-specific çš„ MLIR dialectã€‚

#### å½“å‰çŠ¶æ€
- ğŸŸ¡ å®šä¹‰äº†åŸºæœ¬çš„ systolic dialect
- ğŸŸ¡ ä¸»è¦ä½¿ç”¨ Affine dialect + å±æ€§ï¼ˆattributesï¼‰
- æœªæ¥å¯èƒ½æ‰©å±•ä¸ºå®Œæ•´çš„ systolic operations

### 5. Tools å±‚ (`tools/systolic-translate/`)

æä¾›å‘½ä»¤è¡Œå·¥å…·ã€‚

#### systolic-translate.cpp
- **èŒè´£**: æ•´åˆæ‰€æœ‰ passesï¼Œæä¾› CLI
- **ç”¨æ³•**:
  ```bash
  systolic-translate --emit-hls input.mlir -o output.cpp
  ```
- **å½“å‰é—®é¢˜**:
  - ğŸ”´ ç¡¬ç¼–ç  spacetime=3 é…ç½®ï¼ˆçº¦ 300-350 è¡Œï¼‰
  - ğŸŸ¡ é…ç½®é€‰é¡¹ä¸å®Œæ•´

---

## ç¼–è¯‘æµç¨‹

### å®Œæ•´æµç¨‹å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        è¾“å…¥: Affine MLIR                         â”‚
â”‚  Example: matmul.mlir (3 nested affine.for loops)              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Phase 1: Polymer Analysis (Dependency Analysis)                â”‚
â”‚  â€¢ æ„å»ºå¤šé¢ä½“æ¨¡å‹                                                â”‚
â”‚  â€¢ ISL ä¾èµ–åˆ†æ                                                  â”‚
â”‚  â€¢ ç”Ÿæˆè®¿é—®å…³ç³» (access relations)                               â”‚
â”‚  Output: Scop åˆ†æç»“æœ                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Phase 2: Systolic Transform                                    â”‚
â”‚  â€¢ extractSpaceLoops() â†’ é€‰æ‹© i, j ä½œä¸ºç©ºé—´å¾ªç¯                 â”‚
â”‚  â€¢ extractTimeLoops() â†’ é€‰æ‹© k ä½œä¸ºæ—¶é—´å¾ªç¯                     â”‚
â”‚  â€¢ annotateSystolicConfig() â†’ æ·»åŠ å±æ€§åˆ° IR                     â”‚
â”‚  Output: Annotated Affine IR with systolic attributes           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Phase 3: Array Partitioning Analysis                           â”‚
â”‚  â€¢ åˆ†ææ•°ç»„è®¿é—®æ¨¡å¼                                              â”‚
â”‚  â€¢ å†³å®šåˆ†åŒºç­–ç•¥ (complete/cyclic/block)                         â”‚
â”‚  â€¢ è®¡ç®—åˆ†åŒºç»´åº¦å’Œå› å­                                            â”‚
â”‚  Output: Array partition attributes                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Phase 4: Write-Time Reordering Analysis                        â”‚
â”‚  â€¢ åˆ†æå†™æ“ä½œæ—¶é—´ä¾èµ–                                            â”‚
â”‚  â€¢ è®¡ç®—ä¼˜åŒ–çš„å†™é¡ºåº                                              â”‚
â”‚  âš ï¸ Output: åˆ†æç»“æœï¼ˆå½“å‰æœªä½¿ç”¨ï¼‰                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Phase 5: Dataflow Generation                                   â”‚
â”‚  â€¢ åˆ›å»º DataflowNode å›¾                                          â”‚
â”‚  â€¢ æ’å…¥ PE å‡½æ•°èŠ‚ç‚¹                                              â”‚
â”‚  â€¢ ç”Ÿæˆ FIFO è¿æ¥                                                â”‚
â”‚  â€¢ å¤„ç†æ•°ç»„åˆ†åŒºï¼ˆå£°æ˜ sub-arraysï¼‰                               â”‚
â”‚  Output: Dataflow IR (å†…éƒ¨è¡¨ç¤º)                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Phase 6: HLS Code Generation                                   â”‚
â”‚  â€¢ generateModuleHeader()                                        â”‚
â”‚  â€¢ generateArrayDeclarations() (with partition pragmas)          â”‚
â”‚  â€¢ generatePEFunctions() (âš ï¸ loop body migration TODO)           â”‚
â”‚  â€¢ generateDataflowPragmas() (#pragma HLS dataflow)             â”‚
â”‚  â€¢ generateTopFunction()                                         â”‚
â”‚  Output: HLS C++ (.cpp file)                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                           â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  è¾“å‡º: HLS C++ Code (kernel_*.cpp)                               â”‚
â”‚  Ready for Xilinx Vitis HLS synthesis                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### å…³é”®é˜¶æ®µè¯¦è§£

#### Phase 2: Space/Time Loop Extraction
```
For spacetime=3 (MM kernel):
  i, j, k loops
  â†“
  Space loops: i, j
  Time loops: k
  â†“
  Generate: (t, i, j) systolic array

é…ç½®é€‰æ‹©é€»è¾‘ (å½“å‰ç¡¬ç¼–ç ):
  - spacetime=0: i (1D)
  - spacetime=1: i,j (2D)
  - spacetime=2: i (1D + different projection)
  - spacetime=3: i,j (2D, standard)
  - spacetime=4: i,j,k (3D)
  - spacetime=5: i,j,k (3D, different projection)
```

#### Phase 5: FIFO Depth Calculation
```cpp
// å½“å‰å®ç°ï¼ˆç®€åŒ–ï¼‰
int fifoDepth = calculateFIFODepth(node1, node2) {
  // åŸºäºå¾ªç¯è¾¹ç•Œå’Œä¾èµ–è·ç¦»
  int distance = analyzeDependency(node1, node2);
  return max(2, distance + 1);  // è‡³å°‘æ·±åº¦ 2
}
```

---

## æ•°æ®æµå›¾

### MM (Matrix Multiply) æ•°æ®æµç¤ºä¾‹

```
è¾“å…¥: C[i][j] += A[i][k] * B[k][j]

Spacetime=3 é…ç½®:
  ç©ºé—´ç»´åº¦: i, j â†’ 2D PE array
  æ—¶é—´ç»´åº¦: k â†’ è¿­ä»£ K æ¬¡

æ•°æ®æµ:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                          Top Function                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
          â”œâ”€â–º Load A[i][k] â”€â”€â–º FIFO_A[I][K] â”€â”€â–º PE Array
          â”‚
          â”œâ”€â–º Load B[k][j] â”€â”€â–º FIFO_B[K][J] â”€â”€â–º PE Array
          â”‚
          â””â”€â–º PE Array [I][J] â”€â”€â–º FIFO_C[I][J] â”€â”€â–º Store C[i][j]

PE Array (2D):
    j=0     j=1     j=2    ...  j=J-1
  â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
i=0â”‚ PE  â”‚ PE  â”‚ PE  â”‚...â”‚ PE  â”‚  A[0][k] â†’
  â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤
i=1â”‚ PE  â”‚ PE  â”‚ PE  â”‚...â”‚ PE  â”‚  A[1][k] â†’
  â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤
i=2â”‚ PE  â”‚ PE  â”‚ PE  â”‚...â”‚ PE  â”‚  A[2][k] â†’
  â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤
 ...â”‚ ... â”‚ ... â”‚ ... â”‚...â”‚ ... â”‚
  â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤
i=Iâ”‚ PE  â”‚ PE  â”‚ PE  â”‚...â”‚ PE  â”‚  A[I-1][k] â†’
  â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜
    â†‘     â†‘     â†‘         â†‘
  B[k][0] B[k][1] ...  B[k][J-1]

æ¯ä¸ª PE:
  Input:  A element (from left), B element (from top), partial C
  Compute: C_partial += A * B
  Output: Updated C_partial
```

### FIFO è¿æ¥ç¤ºä¾‹

```
Load_A â”€â”€FIFO(depth=2)â”€â”€â–º PE_row_0
                          â”‚
Load_B â”€â”€FIFO(depth=2)â”€â”€â”€â”€â”¼â”€â”€â–º PE[0][0] â”€â”€FIFOâ”€â”€â–º PE[0][1] â”€â”€ ...
                          â”‚        â”‚
                          â”‚        â””â”€â”€FIFOâ”€â”€â–º Store_C
                          â”‚
                          â””â”€â”€â–º PE[1][0] â”€â”€FIFOâ”€â”€â–º PE[1][1] â”€â”€ ...
```

---

## å…³é”®è®¾è®¡å†³ç­–

### 1. ä¸ºä»€ä¹ˆä½¿ç”¨ Affine Dialect?

**ä¼˜ç‚¹**:
- å¤šé¢ä½“åˆ†æå‹å¥½ï¼ˆPolymer/ISL ç›´æ¥æ”¯æŒï¼‰
- å¾ªç¯ç»“æ„æ¸…æ™°ï¼Œæ˜“äºæå– space/time loops
- MLIR ç”Ÿæ€æˆç†Ÿ

**ç¼ºç‚¹**:
- é™åˆ¶äº†å¾ªç¯ç±»å‹ï¼ˆå¿…é¡»æ˜¯ä»¿å°„å¾ªç¯ï¼‰
- åŠ¨æ€è¾¹ç•Œæ”¯æŒè¾ƒå¼±

### 2. ä¸ºä»€ä¹ˆä¸ä½¿ç”¨å®Œæ•´çš„ Systolic Dialect?

**å½“å‰è®¾è®¡**: Affine IR + å±æ€§ï¼ˆattributesï¼‰
```mlir
affine.for %i ... attributes {systolic.space_loop} {
  affine.for %j ... attributes {systolic.space_loop} {
    affine.for %k ... attributes {systolic.time_loop} {
      ...
    }
  }
}
```

**ç†ç”±**:
- å¿«é€ŸåŸå‹å¼€å‘
- åˆ©ç”¨ç°æœ‰ Affine åŸºç¡€è®¾æ–½
- é™ä½å­¦ä¹ æ›²çº¿

**æœªæ¥è€ƒè™‘**: å®šä¹‰å®Œæ•´çš„ `systolic.pe`, `systolic.dataflow` operations

### 3. é…ç½®æµè®¾è®¡

**å½“å‰æµç¨‹** (é—®é¢˜):
```
SystolicTransform: spacetime â†’ string attribute
                      â†“
DataflowGeneration: parse string â†’ enum
                      â†“
DataflowToHLS: enum â†’ switch cases
```

**é—®é¢˜**:
- å¤šæ¬¡åºåˆ—åŒ–/ååºåˆ—åŒ–
- å®¹æ˜“å‡ºé”™
- æ‰©å±•å›°éš¾

**å»ºè®®æ”¹è¿›**:
```
å®šä¹‰ MLIR Attribute: SystolicConfigAttr
  - spacetime: IntegerAttr
  - spaceLoops: ArrayAttr<IntegerAttr>
  - timeLoops: ArrayAttr<IntegerAttr>
  - arrayPartitions: DictAttr

å…¨æµç¨‹ä¼ é€’ç»“æ„åŒ–å±æ€§ï¼Œé¿å…å­—ç¬¦ä¸²è§£æ
```

### 4. ä¸ºä»€ä¹ˆ Loop Body Migration æ˜¯ TODO?

**åŸå› **:
- å½“å‰åªæ”¯æŒç®€å•çš„ `C[i][j] += A[i][k] * B[k][j]` æ¨¡å¼
- ç¡¬ç¼–ç äº†è®¡ç®—æ¨¡å¼åˆ° PE å‡½æ•°
- é€šç”¨è¿ç§»éœ€è¦å¤„ç†ï¼š
  - ä»»æ„è®¡ç®—è¡¨è¾¾å¼
  - å¤šä¸ªè¯­å¥
  - åµŒå¥—æ¡ä»¶

**å½±å“**: é™åˆ¶äº†æ”¯æŒçš„ kernel ç±»å‹

---

## æ‰©å±•æ€§è€ƒè™‘

### æ·»åŠ æ–°çš„ Spacetime é…ç½®

**å½“å‰ç¡¬ç¼–ç ä½ç½®**:
1. `SystolicTransform.cpp::extractSpaceLoops()` (~185-200)
2. `SystolicDataflowGeneration.cpp::selectSpaceLoops()` (~210-240)
3. `systolic-translate.cpp::parseConfig()` (~300-350)

**æ‰©å±•æ­¥éª¤**:
1. å®šä¹‰ `ParametricSpaceTime` æ•°æ®ç»“æ„
2. é‡æ„ `extractSpaceLoops()` ä¸ºå‚æ•°åŒ–ç‰ˆæœ¬
3. æ›´æ–° dataflow generation é€»è¾‘
4. æ·»åŠ  CLI é€‰é¡¹ `--spacetime=<N>`

### æ·»åŠ æ–°çš„ Kernel ç±»å‹

**å½“å‰é™åˆ¶**: å‡è®¾ 3-loop MM ç»“æ„

**æ‰©å±•æ­¥éª¤**:
1. å®šä¹‰ `KernelInfo` ç»“æ„ï¼ˆloop count, dependenciesï¼‰
2. å®ç°é€šç”¨çš„ loop selection ç®—æ³•
3. å®ç° loop body migration (æ›¿æ¢ TODO)
4. æ·»åŠ  kernel-specific é…ç½®

**ç¤ºä¾‹**: æ”¯æŒ MTTKRP (4 loops)
```cpp
struct KernelInfo {
  int numLoops = 4;  // i, j, k, l
  std::vector<int> spaceLoops = {0, 1};  // i, j
  std::vector<int> timeLoops = {2, 3};   // k, l
};
```

### æ·»åŠ æ–°çš„ä¼˜åŒ– Pass

**ç¤ºä¾‹**: Dataflow ä¼˜åŒ–

1. åˆ›å»ºæ–‡ä»¶ `lib/Transforms/DataflowOptimization.cpp`
2. å®ç° `DataflowOptimizationPass`
3. æ³¨å†Œåˆ° `systolic-translate.cpp`
4. æ·»åŠ åˆ° pass pipeline

```cpp
// åœ¨ systolic-translate.cpp
pm.addPass(createDataflowOptimizationPass());
```

---

## ä¸ AutoSA çš„å¯¹æ¯”

| ç‰¹æ€§ | mlir-systolic | AutoSA | è¯´æ˜ |
|-----|---------------|--------|------|
| **æ¡†æ¶** | MLIR | PoCC/PPCG | mlir-systolic åŸºäºç°ä»£ MLIR åŸºç¡€è®¾æ–½ |
| **Spacetime æ”¯æŒ** | ğŸ”´ ä»… ST3 (å½“å‰) | âœ… ST0-ST5 | AutoSA æ”¯æŒå…¨éƒ¨ 6 ç§é…ç½® |
| **Kernel æ”¯æŒ** | ğŸ”´ ä»… MM | âœ… MM/CNN/MTTKRP ç­‰ | AutoSA æ›´é€šç”¨ |
| **ä»£ç è´¨é‡** | ğŸŸ¡ ä¸­ç­‰ | âœ… é«˜ | AutoSA ç»è¿‡å¤§é‡ä¼˜åŒ– |
| **å¯æ‰©å±•æ€§** | âœ… å¥½ (MLIR) | ğŸŸ¡ ä¸­ç­‰ (C++) | MLIR pass ç³»ç»Ÿæ›´æ˜“æ‰©å±• |
| **æ–‡æ¡£** | ğŸŸ¡ è¿›è¡Œä¸­ | âœ… å®Œå–„ | AutoSA æœ‰å®Œæ•´è®ºæ–‡å’Œæ–‡æ¡£ |
| **ç¤¾åŒº** | ğŸ”´ å° | ğŸŸ¡ ä¸­ç­‰ | MLIR ç¤¾åŒºæ´»è·ƒä½† systolic æ”¯æŒå°‘ |

### æŠ€æœ¯å·®å¼‚

**AutoSA ä¼˜åŠ¿**:
- æˆç†Ÿçš„ spacetime æ˜ å°„ç®—æ³•
- å®Œæ•´çš„ FPGA ä¼˜åŒ–ï¼ˆdouble buffering, latency hidingï¼‰
- æ”¯æŒå¤šç§ç¡¬ä»¶åç«¯

**mlir-systolic æ½œåŠ›**:
- MLIR ç”Ÿæ€ç³»ç»Ÿï¼ˆä¸ TensorFlow/PyTorch é›†æˆï¼‰
- æ¨¡å—åŒ– pass è®¾è®¡
- æœªæ¥å¯æ”¯æŒæ›´å¤š dialectï¼ˆGPU/TPUï¼‰

### ä»£ç ç”Ÿæˆå¯¹æ¯”

**AutoSA ç”Ÿæˆçš„ä»£ç **:
```cpp
// å®Œæ•´çš„ double buffering
for (int t = 0; t < K; t++) {
  #pragma HLS pipeline II=1
  for (int i = 0; i < I; i++) {
    local_A[i][t%2] = A[i][t];  // Ping-pong buffer
  }
  PE_compute(local_A[0][(t-1)%2], ...);
}
```

**mlir-systolic ç”Ÿæˆçš„ä»£ç ** (å½“å‰):
```cpp
// åŸºç¡€ç‰ˆæœ¬
for (int i = 0; i < I; i++) {
  for (int j = 0; j < J; j++) {
    #pragma HLS dataflow
    PE(A_fifo[i], B_fifo[j], C_fifo[i][j]);
  }
}
// âš ï¸ ç¼ºå°‘ latency hiding, double buffering
```

---

## ä¸‹ä¸€æ­¥æ¶æ„æ¼”è¿›

### çŸ­æœŸç›®æ ‡ (1-2 ä¸ªæœˆ)
1. âœ… **å‚æ•°åŒ– Spacetime**: ç§»é™¤æ‰€æœ‰ç¡¬ç¼–ç 
2. âœ… **é€šç”¨åŒ– Kernel**: æ”¯æŒ N-loop ç»“æ„
3. ğŸŸ¡ **å®Œå–„ Loop Body Migration**: å®ç° TODO

### ä¸­æœŸç›®æ ‡ (3-6 ä¸ªæœˆ)
1. å®šä¹‰å®Œæ•´çš„ Systolic Dialect
2. å®ç° double buffering ä¼˜åŒ–
3. æ·»åŠ æ€§èƒ½åˆ†æå·¥å…·

### é•¿æœŸç›®æ ‡ (6+ ä¸ªæœˆ)
1. å¤šåç«¯æ”¯æŒ (Xilinx/Intel/GPU)
2. ä¸ ML æ¡†æ¶é›†æˆ (TensorFlow/PyTorch)
3. è‡ªåŠ¨è°ƒä¼˜ç³»ç»Ÿ

---

## å‚è€ƒèµ„æº

### ä»£ç å¯¼èˆª
- æ ¸å¿ƒå®ç°: [lib/Transforms/SystolicTransform.cpp](../lib/Transforms/SystolicTransform.cpp)
- ä»£ç ç”Ÿæˆ: [lib/Translation/SystolicDataflowToHLS.cpp](../lib/Translation/SystolicDataflowToHLS.cpp)
- æµ‹è¯•: [test/TESTING_GUIDE.md](../test/TESTING_GUIDE.md)
- è¯¦ç»†é—®é¢˜: [CODE_ISSUES_DETAILED_ANALYSIS.md](../CODE_ISSUES_DETAILED_ANALYSIS.md)

### å¤–éƒ¨èµ„æº
- MLIR æ–‡æ¡£: https://mlir.llvm.org/
- Polymer é¡¹ç›®: https://github.com/kumasento/polymer
- AutoSA è®ºæ–‡: [FPGA'21] AutoSA: A Polyhedral Compiler for High-Performance Systolic Arrays

---

## é™„å½•: æœ¯è¯­è¡¨

| æœ¯è¯­ | å®šä¹‰ | ç¤ºä¾‹ |
|-----|------|------|
| **Spacetime** | ç©ºé—´-æ—¶é—´æ˜ å°„é…ç½® | ST3 = 2D ç©ºé—´ + 1D æ—¶é—´ |
| **PE** | Processing Element (å¤„ç†å•å…ƒ) | è„‰åŠ¨é˜µåˆ—ä¸­çš„è®¡ç®—èŠ‚ç‚¹ |
| **FIFO** | First-In-First-Out é˜Ÿåˆ— | PE é—´çš„æ•°æ®ä¼ è¾“é€šé“ |
| **Dataflow** | HLS å¹¶è¡Œæ‰§è¡Œæ¨¡å¼ | `#pragma HLS dataflow` |
| **Array Partition** | æ•°ç»„åˆ†åŒºä¼˜åŒ– | å°†æ•°ç»„æ‹†åˆ†åˆ°å¤šä¸ª BRAM |
| **Affine Loop** | ä»¿å°„å¾ªç¯ | è¾¹ç•Œå’Œç´¢å¼•æ˜¯ä»¿å°„è¡¨è¾¾å¼çš„å¾ªç¯ |
| **Scop** | Static Control Part | å¤šé¢ä½“æ¨¡å‹å¯åˆ†æçš„ä»£ç åŒºåŸŸ |
| **ISL** | Integer Set Library | å¤šé¢ä½“åˆ†æåº“ |

---

**æ–‡æ¡£ç»´æŠ¤**: æ­¤æ–‡æ¡£åº”åœ¨æ¶æ„é‡å¤§å˜æ›´æ—¶æ›´æ–°ã€‚
**æœ€åæ›´æ–°**: 2024 (åˆå§‹ç‰ˆæœ¬)
