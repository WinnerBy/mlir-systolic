# Space-time=3 详细代码差异分析

> **创建时间**: 2024-12-02  
> **目的**: 逐行分析生成代码和参考代码的所有差异，评估对HLS行为的影响

---

## 分析文件路径

### 参考代码（AutoSA 生成）
- **文件路径**: `test/reference-samples/mm_st3_I32_J32_K32_ap8_lat4_simd1_kernel.cpp`
- **来源**: AutoSA 工具生成的 HLS C++ 代码
- **配置**: Space-time=3, I=32, J=32, K=32, array_part=8, latency=4, simd=1
- **总行数**: 1499 行

### 生成代码（mlir-systolic 生成）
- **文件路径**: `test/output/test_I32_J32_K32_ap8_lat4_simd1_kernel.cpp`
- **来源**: mlir-systolic 工具（systolic-translate）生成的 HLS C++ 代码
- **配置**: Space-time=3, I=32, J=32, K=32, array_part=8, latency=4, simd=1
- **总行数**: 1565 行

### 对比方法
- 使用 `diff -u` 进行逐行对比
- 使用自定义脚本进行关键代码段分析
- 手动验证关键函数和循环结构

---

## 执行摘要

### 基本统计

| 指标 | 参考代码 | 生成代码 | 差异 |
|------|---------|---------|------|
| **总行数** | 1499 | 1565 | +66 (+4.4%) |
| **有效代码行数**（去除注释/空行） | 821 | 990 | +169 (+20.6%) |
| **函数数量** | 43 | 55 | +12 |
| **PIPELINE 数量** | 24 | 24 | ✅ 一致 |
| **ARRAY_PARTITION 数量** | 6 | 6 | ✅ 一致 |
| **RESOURCE pragma** | 42 | 75 | +33 |
| **STREAM pragma** | 34 | 68 | +34 |
| **INTERFACE pragma** | 7 | 14 | +7 |
| **DATAFLOW pragma** | 1 | 2 | +1 |

---

## 关键差异分类

### 1. 文件头部差异 ⚠️

**参考代码**:
```cpp
#include <ap_int.h>
#include <hls_stream.h>
```

**生成代码**:
```cpp
//===----------------------------------------------------------------------===//
// Generated by mlir-systolic (systolic-translate)
// Configuration: array_part=8, latency=4, simd=1
// PE Array: 2 x 2
//===----------------------------------------------------------------------===//

#include <ap_int.h>
#include <hls_stream.h>
```

**影响**: ✅ **无影响** - 仅注释，不影响编译和功能

---

### 2. 函数声明组织方式差异 ⚠️

**参考代码**:
```cpp
extern "C" {
void kernel0(A_t16 *A, B_t16 *B, C_t16 *C);
}
void A_IO_L2_in_intra_trans(...);
// ... 其他函数声明
```

**生成代码**:
```cpp
/* Module Declarations */
void A_IO_L3_in(...);
void A_IO_L3_in_serialize(...);
// ... 所有函数声明
/* Module Declarations */
```

**影响**: ✅ **无影响** - 仅组织方式不同，功能等价

---

### 3. 关键功能性差异 ⚠️⚠️

#### 3.1 A_IO_L3_in_serialize 循环边界差异

**参考代码** (第73行):
```cpp
for (ap_uint<9> i = 0; i < 256; i++) {
  #pragma HLS PIPELINE II=1
    mem_data = A[i];
    for (ap_uint<2> p = 0; p < 2; p++) {
      fifo_data = mem_data(255, 0);
      mem_data = mem_data >> 256;
      fifo_A_local_out.write(fifo_data);
    }
}
```

**生成代码** (第58行):
```cpp
for (ap_uint<7> i = 0; i < 64; i++) {
  #pragma HLS PIPELINE II=1
    mem_data = A[i];
    for (ap_uint<2> p = 0; p < 2; p++) {
      fifo_data = mem_data(255, 0);
      mem_data = mem_data >> 256;
      fifo_A_local_out.write(fifo_data);
    }
}
```

**分析**:
- 参考代码: `i < 256`，循环 256 次，每次处理 2 个 `A_t8`，总共 512 个 `A_t8`
- 生成代码: `i < 64`，循环 64 次，每次处理 2 个 `A_t8`，总共 128 个 `A_t8`
- **问题规模**: I=32, J=32, K=32，A 矩阵大小为 32×32 = 1024 个 float
- **每个 A_t16 包含**: 512 bits = 16 个 float
- **需要的 A_t16 数量**: 1024 / 16 = 64 个 ✅
- **参考代码错误**: 256 个 A_t16 会读取超出数组边界的数据 ❌

**影响**: ⚠️⚠️⚠️ **严重问题** - 参考代码可能访问越界，生成代码是正确的

#### 3.2 B_IO_L3_in_serialize 循环边界差异

**参考代码** (第424行):
```cpp
for (ap_uint<9> i = 0; i < 256; i++) {
```

**生成代码** (第402行):
```cpp
for (ap_uint<7> i = 0; i < 64; i++) {
```

**分析**: 与 A_IO_L3_in_serialize 相同的问题

**影响**: ⚠️⚠️⚠️ **严重问题** - 参考代码可能访问越界，生成代码是正确的

---

### 4. A_IO_L2_in_intra_trans 数组索引差异 ⚠️

**参考代码** (第109行):
```cpp
in_data = local_A[c7][c5 / 8];
```

**生成代码** (第119行):
```cpp
in_data = local_A[c7][0];
```

**分析**:
- `c5` 的范围: 0 到 7
- `c5 / 8` = 0（整数除法）
- 所以 `local_A[c7][c5 / 8]` = `local_A[c7][0]`
- **两者等价** ✅

**影响**: ✅ **无影响** - 功能等价，生成代码更简洁

---

### 5. B_IO_L2_in_intra_trans 数组索引差异 ⚠️

**参考代码** (第460行):
```cpp
in_data = local_B[c6][c5 / 8];
```

**生成代码** (第463行):
```cpp
in_data = local_B[c7][0];
```

**分析**:
- 参考代码使用 `c6`，生成代码使用 `c7`
- 需要检查循环结构:
  - 参考代码: `for (c5) for (c6) for (c7)`，使用 `c6`
  - 生成代码: `for (c5) for (c6) for (c7)`，使用 `c7`
- **这是不同的索引变量** ⚠️

**影响**: ⚠️⚠️ **潜在问题** - 需要验证循环语义是否等价

---

### 6. C_drain_IO_L1_out_intra_trans 代码格式差异 ⚠️

**参考代码** (第874行):
```cpp
out_data = (data_split[3], data_split[2], data_split[1], data_split[0]);        local_C[c7][c6 / 4] = out_data;
```

**生成代码** (第868-869行):
```cpp
out_data = (data_split[3], data_split[2], data_split[1], data_split[0]);
local_C[c7][c6 / 4] = out_data;
```

**分析**: 仅格式差异（参考代码两行合并为一行）

**影响**: ✅ **无影响** - 仅格式差异

---

### 7. kernel0 函数重复定义 ⚠️⚠️

**生成代码**:
- 第1165行: `extern "C" { void kernel0(...) { ... } }`
- 第1366行: `extern "C" { void kernel0(...) { ... } }`

**分析**: 生成代码中有**两个完整的 kernel0 函数定义**

**影响**: ⚠️⚠️⚠️ **严重问题** - 会导致链接错误或未定义行为

---

### 8. kernel0 函数调用格式差异 ⚠️

**参考代码**:
```cpp
A_IO_L3_in_serialize(
  /* array */ A,
  /* fifo */ fifo_A_A_IO_L3_in_serialize
);
/* Module Call */

/* Module Call */
A_IO_L3_in(
  /* fifo */ fifo_A_A_IO_L3_in_serialize,
  /* fifo */ fifo_A_A_IO_L2_in_0
);
```

**生成代码**:
```cpp
A_IO_L3_in_serialize(A, fifo_A_A_IO_L3_in_serialize);
A_IO_L3_in(fifo_A_A_IO_L3_in_serialize, fifo_A_A_IO_L2_in_0);
```

**分析**: 仅格式差异（多行 vs 单行，注释 vs 无注释）

**影响**: ✅ **无影响** - 仅格式差异

---

### 9. FIFO 声明注释差异 ⚠️

**参考代码**:
```cpp
/* A_IO_L3_in_serialize fifo */ hls::stream<A_t8> fifo_A_A_IO_L3_in_serialize;
#pragma HLS STREAM variable=fifo_A_A_IO_L3_in_serialize depth=2
```

**生成代码**:
```cpp
hls::stream<A_t8> fifo_A_A_IO_L3_in_serialize;
#pragma HLS STREAM variable=fifo_A_A_IO_L3_in_serialize depth=2
```

**分析**: 仅注释差异

**影响**: ✅ **无影响** - 仅注释差异

---

### 10. RESOURCE 和 STREAM pragma 数量差异 ⚠️

**差异**:
- RESOURCE: 参考代码 42 个，生成代码 75 个（+33）
- STREAM: 参考代码 34 个，生成代码 68 个（+34）

**分析**:
- 生成代码为每个 FIFO 都添加了 `#pragma HLS RESOURCE` 指令
- 参考代码只为部分 FIFO 添加了 RESOURCE 指令

**影响**: ⚠️ **轻微影响** - 可能影响资源分配策略，但通常 HLS 工具会自动推断

---

### 11. DATAFLOW pragma 重复 ⚠️

**生成代码**:
- 第1174行: `#pragma HLS DATAFLOW`
- 第1375行: `#pragma HLS DATAFLOW`（在第二个 kernel0 中）

**分析**: 由于 kernel0 函数重复，DATAFLOW pragma 也重复

**影响**: ⚠️⚠️ **与 kernel0 重复相关

---

## 对 HLS 行为的影响评估

### ✅ 无影响的差异

1. **文件头部注释** - 不影响编译
2. **函数声明组织方式** - 不影响功能
3. **函数调用格式** - 不影响功能
4. **FIFO 声明注释** - 不影响功能
5. **代码格式**（空行、缩进等）- 不影响功能
6. **A_IO_L2_in_intra_trans 数组索引简化** - 功能等价

### ⚠️ 轻微影响的差异

1. **RESOURCE/STREAM pragma 数量** - 可能影响资源分配，但通常 HLS 工具会自动处理
2. **函数调用格式** - 可能影响代码可读性，但不影响功能

### ⚠️⚠️ 需要验证的差异

1. **B_IO_L2_in_intra_trans 数组索引** - 使用 `c7` vs `c6`，需要验证循环语义
   - **参考代码**: `local_B[c6][c5 / 8]` - 使用 `c6` 作为第一维索引
   - **生成代码**: `local_B[c7][0]` - 使用 `c7` 作为第一维索引
   - **循环结构**: 两者都是 `for (c5) for (c6) for (c7)`
   - **分析**: 
     - `c6` 和 `c7` 都是 0-3 的范围，匹配 `local_B[4][1]` 的第一维
     - 但 `c6` 和 `c7` 在循环中的语义可能不同
     - 需要检查 A_IO_L2_in_intra_trans 的模式来确认
   - **对比 A_IO_L2_in_intra_trans**:
     - 参考代码: `local_A[c7][c5 / 8]` - 使用 `c7`
     - 生成代码: `local_A[c7][0]` - 使用 `c7`
     - **结论**: A 使用 `c7`，B 参考代码使用 `c6`，生成代码使用 `c7`
     - **可能原因**: B 的数据流方向与 A 不同，所以索引变量不同
     - **需要验证**: 生成代码使用 `c7` 是否与参考代码使用 `c6` 语义等价

### ⚠️⚠️⚠️ 严重问题

1. **A_IO_L3_in_serialize 循环边界** - 参考代码 `i < 256` 可能越界，生成代码 `i < 64` 正确
2. **B_IO_L3_in_serialize 循环边界** - 参考代码 `i < 256` 可能越界，生成代码 `i < 64` 正确
3. **kernel0 函数重复定义** - 会导致编译/链接错误

---

## 关键发现总结

### 1. 生成代码在某些方面更正确

- ✅ **循环边界正确**: `A_IO_L3_in_serialize` 和 `B_IO_L3_in_serialize` 使用 `i < 64` 是正确的
- ✅ **数组索引简化**: `A_IO_L2_in_intra_trans` 中 `local_A[c7][0]` 比 `local_A[c7][c5 / 8]` 更清晰

### 2. 生成代码存在的问题

- ❌ **kernel0 函数重复定义**: 这是严重的编译错误
  - **确认**: 生成代码中有两个完全相同的 `kernel0` 函数定义
  - **位置**: 第1165行和第1366行
  - **验证**: 两个函数定义完全相同（通过 diff 验证）
  - **影响**: 会导致链接错误或未定义行为
  - **必须修复**: 移除重复的 kernel0 定义
- ⚠️ **B_IO_L2_in_intra_trans 索引变量**: 需要验证 `c7` vs `c6` 是否正确
  - **参考代码**: `local_B[c6][c5 / 8]` - 使用 `c6` 作为第一维索引
  - **生成代码**: `local_B[c7][0]` - 使用 `c7` 作为第一维索引
  - **循环结构**: 两者都是 `for (c5) for (c6) for (c7)`
  - **分析**: `c6` 和 `c7` 都是 0-3，但语义可能不同
  - **对比 A_IO_L2_in_intra_trans**: A 的参考代码和生成代码都使用 `c7`（一致）
  - **需要验证**: 通过功能测试或语义分析确认

### 3. 参考代码可能存在的问题

- ⚠️ **循环边界错误**: `A_IO_L3_in_serialize` 和 `B_IO_L3_in_serialize` 使用 `i < 256` 可能导致越界访问

---

## 建议的修复措施

### 优先级 1: 修复严重问题（必须立即修复）

1. **修复 kernel0 重复定义** ⚠️⚠️⚠️
   - **问题**: 生成代码中有两个完全相同的 `kernel0` 函数定义
   - **位置**: 第1165行和第1366行
   - **影响**: 会导致编译/链接错误
   - **修复**: 移除第二个 kernel0 函数定义（第1365-1565行）
   - **原因分析**: 可能是代码生成器在生成 kernel0 时被调用了两次

### 优先级 2: 验证潜在问题（需要仔细分析）

1. **验证 B_IO_L2_in_intra_trans 索引** ⚠️⚠️
   - **问题**: 参考代码使用 `local_B[c6][c5 / 8]`，生成代码使用 `local_B[c7][0]`
   - **分析**:
     - 循环结构相同: `for (c5: 0-7) for (c6: 0-3) for (c7: 0-3)`
     - `c6` 和 `c7` 都是 0-3，都在有效范围内
     - 但 `c6` 和 `c7` 在循环中的语义可能不同
   - **对比 A_IO_L2_in_intra_trans**:
     - 参考代码和生成代码都使用 `c7`（一致）
     - 但 B 的参考代码使用 `c6`，这可能是因为 B 的数据流方向不同
   - **验证方法**:
     1. 分析循环变量的语义（哪个对应空间维度，哪个对应延迟维度）
     2. 运行功能测试验证生成代码的正确性
     3. 如果测试通过，说明生成代码的 `c7` 是正确的

### 优先级 3: 优化代码生成

1. **统一 RESOURCE pragma 策略**
   - 决定是否为所有 FIFO 添加 RESOURCE pragma
   - 或者让 HLS 工具自动推断

---

## 结论

### 有效代码一致性

- ✅ **核心计算逻辑**: 完全一致
- ✅ **PE 函数**: 完全一致
- ✅ **PIPELINE 数量**: 完全一致（24 个）
- ✅ **数据流结构**: 基本一致

### 主要差异

1. **代码组织方式**: 函数声明/定义的组织方式不同（不影响功能）
2. **代码格式**: 注释、空行、函数调用格式不同（不影响功能）
3. **严重问题**: kernel0 函数重复定义（需要修复）
4. **潜在问题**: B_IO_L2_in_intra_trans 索引变量（需要验证）

### 对 HLS 行为的影响

#### 1. 编译和链接 ⚠️⚠️⚠️

- **kernel0 重复定义**: ❌ **会导致编译/链接错误**
  - 两个相同的函数定义会导致符号冲突
  - 必须修复才能成功编译

#### 2. 功能正确性 ⚠️

- **核心计算逻辑**: ✅ 完全一致（PE 函数、计算语句）
- **数据流结构**: ✅ 基本一致（函数调用顺序相同）
- **循环边界**: ✅ 生成代码更正确（`i < 64` vs `i < 256`）
- **数组索引**: ⚠️ 需要验证（B_IO_L2_in_intra_trans 使用 `c7` vs `c6`）

#### 3. 性能影响 ✅

- **PIPELINE 数量**: ✅ 完全一致（24 个）
- **PIPELINE 位置**: ✅ 一致（都在最内层循环）
- **循环结构**: ✅ 一致（循环嵌套和边界相同）

#### 4. 资源使用 ⚠️

- **RESOURCE pragma**: ⚠️ 数量不同（42 vs 75）
  - 生成代码为更多 FIFO 添加了 RESOURCE pragma
  - 通常 HLS 工具会自动推断，影响较小
- **STREAM pragma**: ⚠️ 数量不同（34 vs 68）
  - 与 RESOURCE pragma 相关
  - 影响较小

#### 5. 代码质量 ⚠️

- **代码格式**: ⚠️ 差异较大（注释、空行、函数调用格式）
  - 不影响功能，但影响可读性
  - 可以后续优化统一格式

---

## 下一步工作

### 立即执行（优先级 1）

1. **修复 kernel0 重复定义** ⚠️⚠️⚠️
   - 检查代码生成逻辑，找出为什么 kernel0 被生成了两次
   - 修复代码生成器，确保 kernel0 只生成一次
   - 验证修复后的代码可以成功编译

### 短期执行（优先级 2）

2. **验证 B_IO_L2_in_intra_trans 索引** ⚠️⚠️
   - 分析循环变量的语义，确认 `c6` 和 `c7` 的含义
   - 运行功能测试，验证生成代码的正确性
   - 如果测试通过，说明生成代码是正确的
   - 如果测试失败，需要修复索引变量

3. **验证循环边界** ✅
   - 确认生成代码的 `i < 64` 是正确的
   - 如果参考代码的 `i < 256` 是错误的，可以忽略

### 长期优化（优先级 3）

4. **统一代码生成格式**
   - 统一函数调用格式（多行 vs 单行）
   - 统一注释风格
   - 减少不必要的空行

5. **优化 RESOURCE pragma 策略**
   - 决定是否为所有 FIFO 添加 RESOURCE pragma
   - 或者让 HLS 工具自动推断

---

---

## 深入分析：循环边界与数据重复访问

> **更新时间**: 2026-01-05  
> **重新评估**: 基于AutoSA参数分析和数据流重用机制

### 1. AutoSA 参数与问题规模的关系

根据 [AutoSA 官方文档](https://autosa.readthedocs.io/en/latest/tutorials/optimize_array.html)：

**array_part（数组分割大小）**：
- 决定了脉动阵列一次处理的数据粒度
- 对于 float32，`array_part=8` 表示处理 8 个 float（256 bits）
- 等价于 `A_t8` 的数据宽度

**problem size 与 array_part 的关系**：
- 原始问题规模（I=32, J=32, K=32）
- 被分割为多个 tile，每个 tile 的大小由 `array_part` 和 `latency` 共同决定
- `tile_size ≈ array_part`
- `num_tiles_per_dim = problem_size / array_part = 32 / 8 = 4`

### 2. 矩阵乘法中的数据重用模式

**在 tiled 矩阵乘法中**：
$$C[i_{tile}][j_{tile}] = \sum_k A[i_{tile}][k_{tile}] \times B[k_{tile}][j_{tile}]$$

关键观察：
- 计算所有 `C[i_t][j_t]` 时，需要 `A[i_t][*]`（A 的所有 k_tile）
- A 矩阵的每个行 tile 被重复使用 `num_tiles` 次（对应 J 维度的每个 tile）
- **数据重用因子 = num_tiles_J = 4**（不是任意的，由问题结构决定）

### 3. Serialize 循环边界的正确计算

**原始数据量**：
$$A_{floats} = 32 \times 32 = 1024 \text{ floats}$$
$$A_{t8\_blocks} = 1024 / 8 = 128 \text{ blocks}$$

**serialize 循环需要提供的数据**：
$$A_{IO\_L3\_in\_requirement} = num\_tiles^3 \times num\_pe \times latency$$
$$= 4 \times 4 \times 4 \times 2 \times 4 = 512 \text{ A\_t8 blocks}$$

**由于数据重用（4x）**：
$$serialize\_iterations = (1024 / 8) \times 4 = 128 \times 4 = 512 / 2 = 256$$

**验证**：
- `serialize i < 256` 提供 `256 × 2 = 512` 个 A_t8 ✓
- `serialize i < 64` 只提供 `64 × 2 = 128` 个 A_t8 ✗ （缺少 384 个）

**结论**：AutoSA 的 `i < 256` **不是错误的**，而是**必要的**！

### 4. 当前 mlir-systolic 代码的关键问题

**数据流不匹配**：
| 模块 | 数据量 | 说明 |
|------|--------|------|
| `A_IO_L3_in_serialize` 输出 | 128 A_t8 | `i < 64` × 2 |
| `A_IO_L3_in` 需求 | 512 A_t8 | 4×4×4×2×4 次迭代 |
| **缺口** | **384 A_t8** | **4x 数据不足** |

这会导致 `A_IO_L3_in` 在消耗 128 个数据后**永久挂起**！

---

## 数据重用方案对比分析

### 1. 方案 A：Host 端数据复用（AutoSA 当前方案）

**实现方式**：
- Host 端在发送前对数据进行复制/展开
- 将单份 A[32×32] 扩展为 4 份重复数据
- FPGA 端 serialize 读取 256 个 A_t16 块
- `A_IO_L3_in` 直接透传数据，无需额外缓冲

**时间开销分析**：
$$T_{host} = T_{serialize} + T_{pcie\_transfer}$$
- $T_{serialize}$ = Host 端数据复制时间（CPU 侧）
- $T_{pcie\_transfer}$ = 4× 原始数据量在 PCIe 上的传输时间
- 对于 32×32 float32 矩阵：原始 4KB → 传输 16KB

**PCIe 带宽开销**：

| 矩阵规模 | 原始大小 | Host 复制方案 | 带宽倍数 |
|---------|----------|---------------|---------|
| 32×32 | 8 KB | 32 KB | 4x |
| 64×64 | 32 KB | 128 KB | 4x |
| 128×128 | 128 KB | 512 KB | 4x |
| 256×256 | 512 KB | 2 MB | 4x |

**资源开销**：
- FPGA BRAM：最小（仅需 2 个 FIFO）
- 逻辑复杂度：低
- Host CPU 开销：数据复制

### 2. 方案 B：FPGA 内部数据重用

**实现方式**：
- serialize 仍然只读 64 个 A_t16（原始数据）
- 在 `A_IO_L3_in` 内部添加本地缓存和重复发送逻辑
- 需要状态机控制数据重用

**时间开销分析**：
$$T_{fpga\_reuse} = T_{pcie\_transfer} + T_{reuse\_logic}$$
- $T_{pcie\_transfer}$ = 1× 原始数据在 PCIe 上的传输时间
- $T_{reuse\_logic}$ = FPGA 内部数据缓存和重复访问的延迟

**FPGA 资源开销**：

| 矩阵规模 | 缓存大小 | BRAM 需求 | 占用百分比 |
|---------|----------|-----------|----------|
| 32×32 | 8 KB | ~2 BRAM36K | <1% |
| 64×64 | 32 KB | ~8 BRAM36K | 1-2% |
| 128×128 | 128 KB | ~32 BRAM36K | 3-5% |
| 256×256 | 512 KB | ~128 BRAM36K | 10-15% |

**注意**：当前 mlir-systolic 的 A_IO_L3_in 仍有其他缓冲需求，实际占用更大。

### 3. 方案 C：分层数据重用（混合方案）

**实现方式**：
- 不在 L3，而在 L2 级别实现数据重用
- L2 缓冲区（`local_A_ping/local_A_pong`）已存在
- 利用 ping-pong 缓冲的特性，在 L2 级别重复访问

**优点**：
- 保持 L3 简单（仅透传）
- L2 缓冲区本来就需要，成本低
- 可以实现部分数据的复用

**代码位置**：
- [A_IO_L2_in](test/output/test_I32_J32_K32_ap8_lat4_simd1_kernel_fixed.cpp#L200)
  已经有 `local_A_ping[4][1]` 和 `local_A_pong[4][1]`
- 可在这一层添加循环重复发送逻辑

### 4. 定量性能/资源权衡

**假设条件**：
- PCIe 3.0 理论带宽：4 GB/s
- FPGA 时钟：250 MHz
- 矩阵规模：32×32

**方案 A（Host 复制）的性能**：
```
数据量：16 KB
PCIe 传输时间：16 KB / 4 GB/s = 4 μs
Host 复制时间：~1-2 μs（CPU 侧）
总数据准备时间：~5-6 μs
```

**方案 B（FPGA 缓存）的性能**：
```
数据量：4 KB
PCIe 传输时间：4 KB / 4 GB/s = 1 μs
FPGA 缓存存取：
  - 写入 4KB：4096 floats / 250MHz ≈ 16 μs（顺序访问）
  - 读取 4 次：4 × 16 μs = 64 μs
总时间：~65-66 μs（受限于 FPGA 存储器带宽）
```

**方案 C（L2 级别混合）的性能**：
```
L2 缓冲：local_A[4][1]（只存储 4 个 A_t8 = 32 floats）
容量：32 floats × 4 bytes = 128 bytes
FPGA 存取时间：可忽略
需要的 serialize 循环：64 次（原始数据）
```

**性能结论**：
1. 如果 PCIe 延迟 ≥ FPGA 计算延迟：方案 A 更优（隐藏 PCIe 延迟）
2. 如果 FPGA 是瓶颈：方案 B 成本太高（缓冲延迟 > PCIe 延迟）
3. **方案 C 最优**：利用现有 L2 缓冲，最小化额外开销

### 5. 建议方案选择

**基于以上分析，推荐 方案 C（分层数据重用）**：

**原因**：
1. **成本最低**：
   - 不需要额外 Host 端代码
   - 不需要额外 FPGA 存储
   - 利用现有 L2 ping-pong 缓冲

2. **性能最优**：
   - PCIe 只传输 1× 原始数据
   - L2 缓冲延迟可忽略
   - 无需等待大量重复数据

3. **复杂度适中**：
   - 修改相对简单
   - 仅需在 `A_IO_L2_in` 的循环中添加重用逻辑
   - 与现有代码结构兼容

**具体实现**：
在 `A_IO_L2_in` 中，将：
```cpp
for (ap_uint<3> c0 = 0; c0 <= 3; c0 += 1)  // 4 iterations
  for (ap_uint<3> c1 = 0; c1 <= 3; c1 += 1)
    for (ap_uint<3> c2 = 0; c2 <= 3; c2 += 1)
      // 处理 A_IO_L2_in_inter_trans（读取新数据）
      // 处理 A_IO_L2_in_intra_trans（使用缓冲数据）
```

改为对不同的 `c1`（或 `c2`）值重复使用相同的 `local_A`：
```cpp
for (ap_uint<3> c0 = 0; c0 <= 3; c0 += 1)  // 4 iterations
  {
    // 第一次：读取 A[c0][*]
    A_IO_L2_in_inter_trans(...);
    
    // 重复 3 次：使用 A[c0][*]（不再读取新数据）
    for (ap_uint<2> reuse = 0; reuse < 3; reuse++) {
      A_IO_L2_in_intra_trans(...);  // 重用缓冲数据
    }
  }
```

---

## 相关文档

- **函数差异分析**: `docs/ST3_FUNCTION_DIFF_ANALYSIS.md`
- **代码验证**: `docs/ST3_CODE_VERIFICATION.md`
- **优化分析**: `docs/ST3_OPTIMIZATION_ANALYSIS.md`

---

## 更新日志

- **2024-12-02**: 创建详细代码差异分析文档
  - 发现 kernel0 函数重复定义问题
  - 发现 A/B_IO_L3_in_serialize 循环边界差异
  
- **2026-01-05**: 深入分析循环边界与数据重用
  - 纠正之前关于 serialize 循环边界的理解
  - AutoSA 的 `i < 256` 是**必要的**（处理数据重用）
  - 发现当前 mlir-systolic 代码关键缺陷：数据流不匹配
  - 提出三种方案对比分析
  - **推荐方案 C（分层数据重用）**为最优方案

