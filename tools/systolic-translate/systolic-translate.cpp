//===----------------------------------------------------------------------===//
//
// systolic-translate - Systolic Array Translation Tool
//
// This tool translates MLIR to HLS C++ code for systolic arrays.
//
//===----------------------------------------------------------------------===//

#include "systolic/Dialect/HLS/HLS.h"

#include "mlir/Dialect/Affine/IR/AffineOps.h"
#include "mlir/Dialect/Arith/IR/Arith.h"
#include "mlir/Dialect/Func/IR/FuncOps.h"
#include "mlir/Dialect/MemRef/IR/MemRef.h"
#include "mlir/IR/BuiltinOps.h"
#include "mlir/IR/BuiltinTypes.h"
#include "mlir/IR/MLIRContext.h"
#include "mlir/Parser/Parser.h"
#include "mlir/Support/FileUtilities.h"
#include "llvm/Support/CommandLine.h"
#include "llvm/Support/InitLLVM.h"
#include "llvm/Support/SourceMgr.h"
#include "llvm/Support/ToolOutputFile.h"
#include "llvm/Support/raw_ostream.h"

#include <string>
#include <sstream>

using namespace mlir;

//===----------------------------------------------------------------------===//
// Command Line Options
//===----------------------------------------------------------------------===//

static llvm::cl::opt<std::string> inputFilename(
    llvm::cl::Positional, llvm::cl::desc("<input file>"), llvm::cl::init("-"));

static llvm::cl::opt<std::string> outputFilename(
    "o", llvm::cl::desc("Output filename"), llvm::cl::value_desc("filename"),
    llvm::cl::init("-"));

static llvm::cl::opt<unsigned> arrayPartSize(
    "array-part", llvm::cl::desc("Array partition size (default: 8)"),
    llvm::cl::init(8));

static llvm::cl::opt<unsigned> latencySize(
    "latency", llvm::cl::desc("Latency hiding factor (default: 4)"),
    llvm::cl::init(4));

static llvm::cl::opt<unsigned> simdFactor(
    "simd", llvm::cl::desc("SIMD factor (default: 1)"),
    llvm::cl::init(1));

static llvm::cl::opt<unsigned> problemSize(
    "size", llvm::cl::desc("Problem size N for NxN matrix (default: 32)"),
    llvm::cl::init(32));

//===----------------------------------------------------------------------===//
// HLS C++ Emitter
//===----------------------------------------------------------------------===//

namespace {

class SystolicHLSEmitter {
public:
  SystolicHLSEmitter(raw_ostream &os, unsigned arrayPart, unsigned latency, 
                     unsigned simd, unsigned size)
      : os(os), arrayPart(arrayPart), latency(latency), simd(simd), size(size),
        numPE(arrayPart / latency),
        tileSize(latency * numPE),  // Each tile is latency * numPE
        numTiles(size / tileSize)   // Number of tile iterations per dimension
        {}

  LogicalResult emit(ModuleOp module);

private:
  raw_ostream &os;
  unsigned arrayPart;
  unsigned latency;
  unsigned simd;
  unsigned size;
  unsigned numPE;
  unsigned tileSize;  // = latency * numPE
  unsigned numTiles;  // = size / tileSize
  unsigned indentLevel = 0;
  unsigned valueCounter = 0;
  
  llvm::DenseMap<Value, std::string> valueNames;
  
  // Indentation helpers
  raw_ostream &indent() { indentLevel++; return os; }
  raw_ostream &dedent() { if (indentLevel > 0) indentLevel--; return os; }
  raw_ostream &emitIndent() {
    for (unsigned i = 0; i < indentLevel; i++) os << "  ";
    return os;
  }
  
  // Type helpers
  std::string getTypeName(Type type);
  std::string getName(Value value);
  
  // Emission methods
  void emitFileHeader();
  void emitTypeDefinitions();
  void emitModuleDeclarations();
  void emitIOL3InSerialize(StringRef arrayName, StringRef typeName, 
                           unsigned totalSize);
  void emitIOL3In(StringRef arrayName, StringRef typeName);
  void emitIOL2InIntraTrans(StringRef arrayName);
  void emitIOL2InInterTrans(StringRef arrayName);
  void emitIOL2In(StringRef arrayName);
  void emitPE();
  void emitPEWrapper();
  void emitDummyModules();
  void emitDrainIOL1(StringRef arrayName);
  void emitDrainIOL2(StringRef arrayName);
  void emitDrainIOL3(StringRef arrayName);
  void emitDrainSerialize(StringRef arrayName, unsigned totalSize);
  void emitTopKernel(func::FuncOp funcOp);
  
  LogicalResult emitFunc(func::FuncOp funcOp);
};

} // namespace

std::string SystolicHLSEmitter::getTypeName(Type type) {
  if (type.isF32()) return "float";
  if (type.isF64()) return "double";
  if (type.isInteger(32)) return "int";
  if (type.isInteger(64)) return "long long";
  if (type.isInteger(16)) return "short";
  if (type.isInteger(8)) return "char";
  return "float";
}

std::string SystolicHLSEmitter::getName(Value value) {
  auto it = valueNames.find(value);
  if (it != valueNames.end()) return it->second;
  std::string name = "v" + std::to_string(valueCounter++);
  valueNames[value] = name;
  return name;
}

void SystolicHLSEmitter::emitFileHeader() {
  os << "//===----------------------------------------------------------------------===//\n";
  os << "// Generated by mlir-systolic (systolic-translate)\n";
  os << "// Configuration: array_part=" << arrayPart << ", latency=" << latency 
     << ", simd=" << simd << "\n";
  os << "// PE Array: " << numPE << " x " << numPE << "\n";
  os << "//===----------------------------------------------------------------------===//\n\n";
  
  os << "#include <ap_int.h>\n";
  os << "#include <hls_stream.h>\n\n";
  
  os << "#define min(x,y) ((x < y) ? x : y)\n";
  os << "#define max(x,y) ((x > y) ? x : y)\n\n";
}

void SystolicHLSEmitter::emitTypeDefinitions() {
  os << "/* Data Type */\n";
  os << "typedef float A_t1;\n";
  os << "typedef float B_t1;\n";
  os << "typedef float C_t1;\n";
  
  // Packed types based on array_part
  unsigned packBits = arrayPart * 32;
  os << "typedef ap_uint<512> A_t16;\n";
  os << "typedef ap_uint<" << (arrayPart * 32) << "> A_t" << arrayPart << ";\n";
  os << "typedef ap_uint<512> B_t16;\n";
  os << "typedef ap_uint<" << (arrayPart * 32) << "> B_t" << arrayPart << ";\n";
  os << "typedef ap_uint<512> C_t16;\n";
  os << "typedef ap_uint<" << (latency * 32) << "> C_t" << latency << ";\n";
  os << "/* Data Type */\n\n";
}

void SystolicHLSEmitter::emitModuleDeclarations() {
  os << "/* Module Declarations */\n";
  os << "void A_IO_L3_in(hls::stream<A_t" << arrayPart << "> &fifo_A_in, "
     << "hls::stream<A_t" << arrayPart << "> &fifo_A_local_out);\n";
  os << "void A_IO_L3_in_serialize(A_t16 *A, hls::stream<A_t" << arrayPart 
     << "> &fifo_A_local_out);\n";
  os << "void A_IO_L2_in(int idx, hls::stream<A_t" << arrayPart << "> &fifo_A_in, "
     << "hls::stream<A_t" << arrayPart << "> &fifo_A_out, "
     << "hls::stream<float> &fifo_A_local_out);\n";
  os << "void B_IO_L3_in(hls::stream<B_t" << arrayPart << "> &fifo_B_in, "
     << "hls::stream<B_t" << arrayPart << "> &fifo_B_local_out);\n";
  os << "void B_IO_L3_in_serialize(B_t16 *B, hls::stream<B_t" << arrayPart 
     << "> &fifo_B_local_out);\n";
  os << "void B_IO_L2_in(int idx, hls::stream<B_t" << arrayPart << "> &fifo_B_in, "
     << "hls::stream<B_t" << arrayPart << "> &fifo_B_out, "
     << "hls::stream<float> &fifo_B_local_out);\n";
  os << "void PE_wrapper(int idx, int idy, "
     << "hls::stream<float> &fifo_A_in, hls::stream<float> &fifo_A_out, "
     << "hls::stream<float> &fifo_B_in, hls::stream<float> &fifo_B_out, "
     << "hls::stream<float> &fifo_C_drain_out);\n";
  os << "void C_drain_IO_L1_out_wrapper(int idx, int idy, "
     << "hls::stream<C_t" << latency << "> &fifo_C_drain_in, "
     << "hls::stream<C_t" << latency << "> &fifo_C_drain_out, "
     << "hls::stream<float> &fifo_C_drain_local_in);\n";
  os << "/* Module Declarations */\n\n";
}

void SystolicHLSEmitter::emitIOL3InSerialize(StringRef arrayName, 
                                              StringRef typeName,
                                              unsigned totalSize) {
  os << "/* Module Definition */\n";
  os << "void " << arrayName << "_IO_L3_in_serialize(" << arrayName 
     << "_t16 *" << arrayName << ", hls::stream<" << arrayName << "_t" 
     << arrayPart << "> &fifo_" << arrayName << "_local_out) {\n";
  os << "#pragma HLS INLINE OFF\n";
  os << "  /* Variable Declaration */\n";
  os << "  " << arrayName << "_t" << arrayPart << " fifo_data;\n";
  os << "  " << arrayName << "_t16 mem_data;\n";
  
  unsigned iterations = (totalSize * totalSize * 4) / 64;  // 512 bits = 64 bytes
  os << "  for (ap_uint<" << (unsigned)ceil(log2(iterations + 1)) << "> i = 0; i < " 
     << iterations << "; i++) {\n";
  os << "  #pragma HLS PIPELINE II=1\n";
  os << "    mem_data = " << arrayName << "[i];\n";
  os << "    for (ap_uint<2> p = 0; p < 2; p++) {\n";
  os << "      fifo_data = mem_data(" << (arrayPart * 32 - 1) << ", 0);\n";
  os << "      mem_data = mem_data >> " << (arrayPart * 32) << ";\n";
  os << "      fifo_" << arrayName << "_local_out.write(fifo_data);\n";
  os << "    }\n";
  os << "  }\n";
  os << "}\n";
  os << "/* Module Definition */\n\n";
}

void SystolicHLSEmitter::emitIOL3In(StringRef arrayName, StringRef typeName) {
  os << "/* Module Definition */\n";
  os << "void " << arrayName << "_IO_L3_in(hls::stream<" << arrayName << "_t" 
     << arrayPart << "> &fifo_" << arrayName << "_in, hls::stream<" 
     << arrayName << "_t" << arrayPart << "> &fifo_" << arrayName 
     << "_local_out) {\n";
  os << "#pragma HLS INLINE OFF\n";
  // c0, c1, c2 iterate over tiles: numTiles = size / (latency * numPE)
  os << "  for (ap_uint<3> c0 = 0; c0 <= " << (numTiles - 1) << "; c0 += 1)\n";
  os << "    for (ap_uint<3> c1 = 0; c1 <= " << (numTiles - 1) << "; c1 += 1)\n";
  os << "      for (ap_uint<3> c2 = 0; c2 <= " << (numTiles - 1) << "; c2 += 1) {\n";
  os << "        // io_L3\n";
  os << "        for (ap_uint<2> c3 = 0; c3 <= " << (numPE - 1) << "; c3 += 1) {\n";
  os << "          // io_L2\n";
  os << "          for (ap_uint<3> c4 = 0; c4 <= " << (latency - 1) << "; c4 += 1) {\n";
  os << "          #pragma HLS PIPELINE II=1\n";
  os << "            // access_coalesce\n";
  os << "            // access_serialize\n";
  os << "            {\n";
  os << "              " << arrayName << "_t" << arrayPart << " in_data;\n";
  os << "              " << arrayName << "_t" << arrayPart << " out_data;\n";
  os << "              in_data = fifo_" << arrayName << "_in.read();\n";
  os << "              out_data = in_data;\n";
  os << "              fifo_" << arrayName << "_local_out.write(out_data);\n";
  os << "            }\n";
  os << "          }\n";
  os << "        }\n";
  os << "      }\n";
  os << "}\n";
  os << "/* Module Definition */\n\n";
}

void SystolicHLSEmitter::emitPE() {
  // c5 bound: arrayPart / simd = 8 / 1 = 8 iterations (0 to 7)
  unsigned c5Bound = arrayPart / simd;
  
  os << "/* Module Definition */\n";
  os << "void PE(int idx, int idy, "
     << "hls::stream<float> &fifo_A_in, hls::stream<float> &fifo_A_out, "
     << "hls::stream<float> &fifo_B_in, hls::stream<float> &fifo_B_out, "
     << "hls::stream<float> &fifo_C_drain_out) {\n";
  os << "#pragma HLS INLINE OFF\n";
  os << "  /* Variable Declaration */\n";
  os << "  int p0 = idx, p1 = idy; // module id\n";
  os << "  A_t1 local_A[1][1];\n";
  os << "  #pragma HLS ARRAY_PARTITION variable=local_A dim=0 complete\n";
  os << "  B_t1 local_B[1][1];\n";
  os << "  #pragma HLS ARRAY_PARTITION variable=local_B dim=0 complete\n";
  os << "  C_t1 local_C[" << latency << "][" << latency << "];\n";
  os << "  #pragma HLS RESOURCE variable=local_C core=RAM_2P_BRAM\n";
  os << "  /* Variable Declaration */\n\n";
  
  // Main computation loops - c0, c1, c2 iterate over numTiles
  os << "  for (ap_uint<3> c0 = 0; c0 <= " << (numTiles - 1) << "; c0 += 1)\n";
  os << "    for (ap_uint<3> c1 = 0; c1 <= " << (numTiles - 1) << "; c1 += 1)\n";
  os << "      for (ap_uint<3> c2 = 0; c2 <= " << (numTiles - 1) << "; c2 += 1) {\n";
  os << "        // array\n";
  os << "        // pe\n";
  os << "        for (ap_uint<4> c5 = 0; c5 <= " << (c5Bound - 1) << "; c5 += 1) {\n";
  os << "          // latency\n";
  os << "          for (ap_uint<3> c6 = 0; c6 <= " << (latency - 1) << "; c6 += 1) {\n";
  os << "            // latency\n";
  os << "            for (ap_uint<3> c7 = 0; c7 <= " << (latency - 1) << "; c7 += 1) {\n";
  os << "            #pragma HLS PIPELINE II=1\n";
  os << "              {\n";
  os << "                local_A[0][0] = fifo_A_in.read();\n";
  os << "                local_B[0][0] = fifo_B_in.read();\n";
  os << "                local_C[c7][c6] = (local_C[c7][c6] + (local_A[0][0] * local_B[0][0]));\n";
  os << "                if (c2 == " << (numTiles - 1) << " && c5 == " << (c5Bound - 1) << ")\n";
  os << "                  fifo_C_drain_out.write(local_C[c7][c6]);\n";
  os << "                fifo_B_out.write(local_B[0][0]);\n";
  os << "                fifo_A_out.write(local_A[0][0]);\n";
  os << "              }\n";
  os << "            }\n";
  os << "          }\n";
  os << "        }\n";
  os << "      }\n";
  os << "}\n";
  os << "/* Module Definition */\n\n";
}

void SystolicHLSEmitter::emitPEWrapper() {
  os << "/* Module Definition */\n";
  os << "void PE_wrapper(int idx, int idy, "
     << "hls::stream<float> &fifo_A_in, hls::stream<float> &fifo_A_out, "
     << "hls::stream<float> &fifo_B_in, hls::stream<float> &fifo_B_out, "
     << "hls::stream<float> &fifo_C_drain_out) {\n";
  os << "  PE(idx, idy, fifo_A_in, fifo_A_out, fifo_B_in, fifo_B_out, "
     << "fifo_C_drain_out);\n";
  os << "}\n";
  os << "/* Module Definition */\n\n";
}

void SystolicHLSEmitter::emitDummyModules() {
  unsigned c5Bound = arrayPart / simd;
  
  // A dummy module
  os << "/* Module Definition */\n";
  os << "void A_PE_dummy_in(int idx, int idy, hls::stream<float> &fifo_A_in) {\n";
  os << "  /* Variable Declaration */\n";
  os << "  int p0 = idx, p1 = idy; // module id\n";
  os << "  /* Variable Declaration */\n\n";
  os << "  for (ap_uint<3> c0 = 0; c0 <= " << (numTiles - 1) << "; c0 += 1)\n";
  os << "    for (ap_uint<3> c1 = 0; c1 <= " << (numTiles - 1) << "; c1 += 1)\n";
  os << "      for (ap_uint<3> c2 = 0; c2 <= " << (numTiles - 1) << "; c2 += 1) {\n";
  os << "        // array\n";
  os << "        // pe\n";
  os << "        for (ap_uint<4> c5 = 0; c5 <= " << (c5Bound - 1) << "; c5 += 1) {\n";
  os << "          // latency\n";
  os << "          for (ap_uint<3> c6 = 0; c6 <= " << (latency - 1) << "; c6 += 1) {\n";
  os << "            // latency\n";
  os << "            for (ap_uint<3> c7 = 0; c7 <= " << (latency - 1) << "; c7 += 1) {\n";
  os << "            #pragma HLS PIPELINE II=1\n";
  os << "              A_t1 fifo_data;\n";
  os << "              fifo_data = fifo_A_in.read();\n";
  os << "            }\n";
  os << "          }\n";
  os << "        }\n";
  os << "      }\n";
  os << "}\n";
  os << "/* Module Definition */\n\n";
  
  // B dummy module
  os << "/* Module Definition */\n";
  os << "void B_PE_dummy_in(int idx, int idy, hls::stream<float> &fifo_B_in) {\n";
  os << "  /* Variable Declaration */\n";
  os << "  int p0 = idx, p1 = idy; // module id\n";
  os << "  /* Variable Declaration */\n\n";
  os << "  for (ap_uint<3> c0 = 0; c0 <= " << (numTiles - 1) << "; c0 += 1)\n";
  os << "    for (ap_uint<3> c1 = 0; c1 <= " << (numTiles - 1) << "; c1 += 1)\n";
  os << "      for (ap_uint<3> c2 = 0; c2 <= " << (numTiles - 1) << "; c2 += 1) {\n";
  os << "        // array\n";
  os << "        // pe\n";
  os << "        for (ap_uint<4> c5 = 0; c5 <= " << (c5Bound - 1) << "; c5 += 1) {\n";
  os << "          // latency\n";
  os << "          for (ap_uint<3> c6 = 0; c6 <= " << (latency - 1) << "; c6 += 1) {\n";
  os << "            // latency\n";
  os << "            for (ap_uint<3> c7 = 0; c7 <= " << (latency - 1) << "; c7 += 1) {\n";
  os << "            #pragma HLS PIPELINE II=1\n";
  os << "              B_t1 fifo_data;\n";
  os << "              fifo_data = fifo_B_in.read();\n";
  os << "            }\n";
  os << "          }\n";
  os << "        }\n";
  os << "      }\n";
  os << "}\n";
  os << "/* Module Definition */\n\n";
}

void SystolicHLSEmitter::emitTopKernel(func::FuncOp funcOp) {
  os << "extern \"C\" {\n";
  os << "void kernel0(A_t16 *A, B_t16 *B, C_t16 *C) {\n";
  os << "#pragma HLS INTERFACE m_axi port=A offset=slave bundle=gmem_A\n";
  os << "#pragma HLS INTERFACE m_axi port=B offset=slave bundle=gmem_B\n";
  os << "#pragma HLS INTERFACE m_axi port=C offset=slave bundle=gmem_C\n";
  os << "#pragma HLS INTERFACE s_axilite port=A bundle=control\n";
  os << "#pragma HLS INTERFACE s_axilite port=B bundle=control\n";
  os << "#pragma HLS INTERFACE s_axilite port=C bundle=control\n";
  os << "#pragma HLS INTERFACE s_axilite port=return bundle=control\n\n";
  os << "#pragma HLS DATAFLOW\n\n";
  
  // FIFO declarations
  os << "  /* FIFO Declaration */\n";
  os << "  hls::stream<A_t" << arrayPart << "> fifo_A_A_IO_L3_in_serialize;\n";
  os << "  #pragma HLS STREAM variable=fifo_A_A_IO_L3_in_serialize depth=2\n";
  os << "  hls::stream<B_t" << arrayPart << "> fifo_B_B_IO_L3_in_serialize;\n";
  os << "  #pragma HLS STREAM variable=fifo_B_B_IO_L3_in_serialize depth=2\n";
  os << "  hls::stream<C_t" << latency << "> fifo_C_drain_C_drain_IO_L3_out_serialize;\n";
  os << "  #pragma HLS STREAM variable=fifo_C_drain_C_drain_IO_L3_out_serialize depth=2\n\n";
  
  // L2 FIFOs
  for (unsigned i = 0; i <= numPE; i++) {
    os << "  hls::stream<A_t" << arrayPart << "> fifo_A_A_IO_L2_in_" << i << ";\n";
    os << "  #pragma HLS STREAM variable=fifo_A_A_IO_L2_in_" << i << " depth=2\n";
    os << "  #pragma HLS RESOURCE variable=fifo_A_A_IO_L2_in_" << i << " core=FIFO_SRL\n";
  }
  for (unsigned i = 0; i <= numPE; i++) {
    os << "  hls::stream<B_t" << arrayPart << "> fifo_B_B_IO_L2_in_" << i << ";\n";
    os << "  #pragma HLS STREAM variable=fifo_B_B_IO_L2_in_" << i << " depth=2\n";
    os << "  #pragma HLS RESOURCE variable=fifo_B_B_IO_L2_in_" << i << " core=FIFO_SRL\n";
  }
  
  // PE FIFOs
  for (unsigned i = 0; i < numPE; i++) {
    for (unsigned j = 0; j <= numPE; j++) {
      os << "  hls::stream<float> fifo_A_PE_" << i << "_" << j << ";\n";
      os << "  #pragma HLS STREAM variable=fifo_A_PE_" << i << "_" << j << " depth=2\n";
      os << "  #pragma HLS RESOURCE variable=fifo_A_PE_" << i << "_" << j << " core=FIFO_SRL\n";
    }
  }
  for (unsigned i = 0; i <= numPE; i++) {
    for (unsigned j = 0; j < numPE; j++) {
      os << "  hls::stream<float> fifo_B_PE_" << i << "_" << j << ";\n";
      os << "  #pragma HLS STREAM variable=fifo_B_PE_" << i << "_" << j << " depth=2\n";
      os << "  #pragma HLS RESOURCE variable=fifo_B_PE_" << i << "_" << j << " core=FIFO_SRL\n";
    }
  }
  for (unsigned i = 0; i < numPE; i++) {
    for (unsigned j = 0; j < numPE; j++) {
      os << "  hls::stream<float> fifo_C_drain_PE_" << i << "_" << j << ";\n";
      os << "  #pragma HLS STREAM variable=fifo_C_drain_PE_" << i << "_" << j << " depth=2\n";
      os << "  #pragma HLS RESOURCE variable=fifo_C_drain_PE_" << i << "_" << j << " core=FIFO_SRL\n";
    }
  }
  os << "  /* FIFO Declaration */\n\n";
  
  // Module calls
  os << "  /* Module Call */\n";
  os << "  A_IO_L3_in_serialize(A, fifo_A_A_IO_L3_in_serialize);\n";
  os << "  A_IO_L3_in(fifo_A_A_IO_L3_in_serialize, fifo_A_A_IO_L2_in_0);\n";
  for (unsigned i = 0; i < numPE - 1; i++) {
    os << "  A_IO_L2_in(" << i << ", fifo_A_A_IO_L2_in_" << i 
       << ", fifo_A_A_IO_L2_in_" << (i + 1) << ", fifo_A_PE_" << i << "_0);\n";
  }
  os << "  A_IO_L2_in_boundary(" << (numPE - 1) << ", fifo_A_A_IO_L2_in_" 
     << (numPE - 1) << ", fifo_A_PE_" << (numPE - 1) << "_0);\n\n";
  
  os << "  B_IO_L3_in_serialize(B, fifo_B_B_IO_L3_in_serialize);\n";
  os << "  B_IO_L3_in(fifo_B_B_IO_L3_in_serialize, fifo_B_B_IO_L2_in_0);\n";
  for (unsigned i = 0; i < numPE - 1; i++) {
    os << "  B_IO_L2_in(" << i << ", fifo_B_B_IO_L2_in_" << i 
       << ", fifo_B_B_IO_L2_in_" << (i + 1) << ", fifo_B_PE_0_" << i << ");\n";
  }
  os << "  B_IO_L2_in_boundary(" << (numPE - 1) << ", fifo_B_B_IO_L2_in_" 
     << (numPE - 1) << ", fifo_B_PE_0_" << (numPE - 1) << ");\n\n";
  
  // PE array calls
  for (unsigned i = 0; i < numPE; i++) {
    for (unsigned j = 0; j < numPE; j++) {
      os << "  PE_wrapper(" << i << ", " << j << ", "
         << "fifo_A_PE_" << i << "_" << j << ", fifo_A_PE_" << i << "_" << (j + 1) << ", "
         << "fifo_B_PE_" << i << "_" << j << ", fifo_B_PE_" << (i + 1) << "_" << j << ", "
         << "fifo_C_drain_PE_" << i << "_" << j << ");\n";
    }
  }
  os << "\n";
  
  // Dummy modules
  for (unsigned i = 0; i < numPE; i++) {
    os << "  A_PE_dummy_in(" << i << ", " << (numPE - 1) << ", fifo_A_PE_" 
       << i << "_" << numPE << ");\n";
  }
  for (unsigned j = 0; j < numPE; j++) {
    os << "  B_PE_dummy_in(" << (numPE - 1) << ", " << j << ", fifo_B_PE_" 
       << numPE << "_" << j << ");\n";
  }
  os << "\n";
  
  // Drain modules (simplified)
  os << "  /* C drain modules - simplified */\n";
  os << "  C_drain_IO_L3_out_serialize(C, fifo_C_drain_C_drain_IO_L3_out_serialize);\n";
  
  os << "}\n";
  os << "}\n";
}

LogicalResult SystolicHLSEmitter::emitFunc(func::FuncOp funcOp) {
  emitTopKernel(funcOp);
  return success();
}

LogicalResult SystolicHLSEmitter::emit(ModuleOp module) {
  emitFileHeader();
  emitTypeDefinitions();
  emitModuleDeclarations();
  
  // Emit module implementations
  emitIOL3InSerialize("A", "float", 32);
  emitIOL3In("A", "float");
  emitIOL3InSerialize("B", "float", 32);
  emitIOL3In("B", "float");
  emitPE();
  emitPEWrapper();
  emitDummyModules();
  
  // Emit top kernel
  for (auto func : module.getOps<func::FuncOp>()) {
    if (failed(emitFunc(func)))
      return failure();
  }
  
  return success();
}

//===----------------------------------------------------------------------===//
// Main
//===----------------------------------------------------------------------===//

int main(int argc, char **argv) {
  llvm::InitLLVM y(argc, argv);
  llvm::cl::ParseCommandLineOptions(argc, argv, "Systolic HLS C++ Translator\n");
  
  // Set up context
  MLIRContext context;
  context.getOrLoadDialect<affine::AffineDialect>();
  context.getOrLoadDialect<arith::ArithDialect>();
  context.getOrLoadDialect<func::FuncDialect>();
  context.getOrLoadDialect<memref::MemRefDialect>();
  
  // Parse input
  std::string errorMessage;
  auto file = openInputFile(inputFilename, &errorMessage);
  if (!file) {
    llvm::errs() << errorMessage << "\n";
    return 1;
  }
  
  llvm::SourceMgr sourceMgr;
  sourceMgr.AddNewSourceBuffer(std::move(file), llvm::SMLoc());
  
  auto module = parseSourceFile<ModuleOp>(sourceMgr, &context);
  if (!module) {
    llvm::errs() << "Failed to parse input file\n";
    return 1;
  }
  
  // Set up output
  auto output = openOutputFile(outputFilename, &errorMessage);
  if (!output) {
    llvm::errs() << errorMessage << "\n";
    return 1;
  }
  
  // Emit HLS C++
  SystolicHLSEmitter emitter(output->os(), arrayPartSize, latencySize, simdFactor, problemSize);
  if (failed(emitter.emit(*module))) {
    llvm::errs() << "Failed to emit HLS C++\n";
    return 1;
  }
  
  output->keep();
  return 0;
}
